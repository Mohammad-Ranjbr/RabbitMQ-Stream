📌 Offset Concept in RabbitMQ Stream
🔹 What is Offset?
Offset is a unique number for each message in a Stream that specifies the order of messages.
🔹 When a Consumer (message consumer) reads messages in a RabbitMQ Stream,
RabbitMQ uses Offset to understand how far this Consumer has processed the messages.

If a Consumer reads the messages from the beginning:
✅ It will first receive message 0, then 1, then 2, and so on.
But if a new Consumer joins the Stream after 5 messages have been sent:
✅ It can choose to read only message 5 onwards.

Types of Offset in RabbitMQ Stream
🔹 In RabbitMQ Stream, you can specify from which point a Consumer should start reading messages.

✅ 1. Read from the first message (all previous and new messages)
        - OffsetSpecification.first()

✍🏼 Explanation:
Reads all previous messages + new messages.
Even if the Consumer is turned off and on again, it will start reading again from the first message.

✅ 2. Read from new messages (previous messages are not read)
        - OffsetSpecification.next()

✍🏼 Explanation:
Only new messages sent after the Consumer is turned on are read.
Older messages in the Stream are ignored.

✅ 3. Reading from the last section of messages
        - OffsetSpecification.last()

✍🏼 Explanation:
Start from the last saved message.

RabbitMQ stores messages in large chunks to optimize performance.
If the number of messages is large, RabbitMQ stores them in multiple chunks.
🟡 Example: If there are 17,000 messages in the Stream:
Chunk 1: Messages 1 to 10,000
Chunk 2: Messages 10,001 to 17,000
✅ Using OffsetSpecification.last(), the Consumer will start reading from the beginning of Chunk 2.
✅ 4. Reading based on a specific time
        - OffsetSpecification.timestamp(Instant.now().minusSeconds(300))

✍🏼 Explanation:
You can specify that messages from a specific time onwards are read.
For example, all messages sent in the last 5 minutes.

5. Absolute

✍🏼 Explanation:
Receive messages from offset number 3 onwards

📌 Storing Offset in RabbitMQ
🔹 RabbitMQ automatically stores the Offset of each Consumer.
🔹 If the application is shut down and restarted, it will continue from the last message read.

✅ Unique naming for each Consumer must have a unique name so that RabbitMQ can track the Offset read.

🚨 Important note:
If two Consumers share the same name, they may randomly share messages between each other.

Offset Concept
Every time a message is sent to a RabbitMQ stream, a unique identifier called an offset is assigned to that message.
 This offset represents the position of that message in the stream. This value starts at 0 and increases sequentially for each new message.

Offset Tracking
In RabbitMQ Stream, offset tracking means that the system must keep track of the consumers' positions in the stream,
so that the consumer can pick up new messages from where it left off. This tracking is done through information such as "when did a consumer start reading from what offset?".

To do this, RabbitMQ automatically adds a series of tracking messages to the stream, which contain information about the consumer's
position (e.g., which offset did it start from) and the time the messages were sent.

Why do tracking messages increase the number of messages?

Trace messages themselves are not actual messages sent from the producer.
They are automatically generated by RabbitMQ and added to the stream to store information about the state of the consumers.

Therefore, when you use offset trace strategies, additional messages (relating to the trace) are added to the stream,
resulting in a total number of messages in the stream that are greater than the actual messages (sent from the producer).

How can I prevent these messages?
If for some reason you don't want tracking messages to be stored in the stream, you can disable offset tracking strategies or manage them manually,
but this is usually not advisable as it may negatively impact consumer behavior and prevent you from being able to track consumer locations properly.

Tracking messages are independent of the actual messages and are only used to manage the position of consumers in the stream.
While the number of messages in the stream increases, these messages will not affect the consumer logic, because consumers only read the actual messages and not the tracking messages.

🔹 In RabbitMQ Stream, additional messages containing Offset tracking information are stored in the Stream.
🔹 These messages are automatically generated by RabbitMQ and increase the total number of messages in the Stream.

✅ These tracking messages are not processed by the Consumer, but are seen in the Stream message count.
✅ For this reason, the Offset value should not be used as a measure of the actual number of messages in the Stream.

When using the manual offset tracking strategy, the consumer must manually manage the offset state (i.e., from which message to start consuming).
Automatic Offset Tracking: In this case, the system automatically stores the offset of the last message consumed, and the consumer continues from that point after restarting.
Manual Offset Tracking: In this case, the consumer must store and track the offset itself, meaning that the system never automatically knows where the last message was.
It is recommended to store offsets regularly (e.g., every few thousand messages) to prevent unnecessary stream growth.

🔹 Difference between Queue and Stream
Queue: In a queue, each message is received and processed by only one consumer. This means that consumers process different messages in parallel and independently.
Stream: In a stream, each message may be processed by multiple consumers. This means that a message may be processed multiple times.

🔹 What is Single Active Consumer?
✅ Single Active Consumer is a feature that allows only one active consumer to process messages, even if multiple consumers are connected.
⏳ If this active consumer crashes or fails, RabbitMQ automatically replaces another consumer as the active consumer.

🔸 Challenges in Single Active Consumer
🔹 When a consumer stops and another consumer starts, there is a possibility that some messages that have already been processed will be reprocessed.
🔹 This happens because the offset is not stored per message. RabbitMQ only stores the offset at certain intervals (e.g. every few thousand messages). So if a consumer stops after processing several messages, some of those messages may be processed again by the next consumer.

🔹 What is an Idempotent Consumer?
✅ To prevent reprocessing of messages, an Idempotent Consumer can be created.

🔸 How to implement an Idempotent Consumer
Each message must have a unique ID.
When a consumer receives a message:
First, it checks whether this ID has been processed before.
If this ID has been processed before, it ignores it.
Otherwise, the message is processed and its ID is stored in the list of processed messages.
🔹 This list can be:

A table in a database.

Stored in memory (like Redis) that keeps the IDs for a limited time (say 30 minutes).
✅ This method ensures that even if RabbitMQ resends some messages, the consumer ignores duplicate messages.
